pragma circom 2.1.5;

include "../../node_modules/ec-elgamal-circuit/circuits/decrypt.circom";
include "../../node_modules/ec-elgamal-circuit/circuits/onCurve.circom";
include "../../node_modules/circomlib/circuits/poseidon.circom";

include "./verify_key.circom";

/*
* Guide:
* ---
* pk - public key:
* public keys consist of two points: alpha and beta (sk * alpha)
* alpha: (pk[0][0], pk[0][1]), beta: (pk[1][0], pk[1][1])
*
* sk - secret key:
* scalar value
*
* encrypted messages:
* encrypted messages consist of two points: first is nonce point (nonce * alpha), second is encrypted message (x + nonce * beta)
* nonce point: (em[0][0], em[0][1]), message: ([em[1][0], em[1][1])
*/


template SameIdentity() {
    // public
    signal input pk1[2][2];  
    signal input pk2[2][2]; 
    signal input sk1BySk2[2][2];
    signal input sk2BySk1[2][2];

    // private
    signal input sk1;
    signal input sk2;

    // on-curve validation
    // public keys
    component pk1_1 = OnCurve();
    component pk1_2 = OnCurve();
    component pk2_1 = OnCurve();
    component pk2_2 = OnCurve();

    // messages
    component sk1BySk2_1 = OnCurve();
    component sk1BySk2_2 = OnCurve();
    component sk2BySk1_1 = OnCurve();
    component sk2BySk1_2 = OnCurve();

    pk1_1.p <== pk1[0];
    pk1_2.p <== pk1[1];
    pk2_1.p <== pk2[0];
    pk2_2.p <== pk2[1];

    sk1BySk2_1.p <== sk1BySk2[0];
    sk1BySk2_2.p <== sk1BySk2[1];
    sk2BySk1_1.p <== sk2BySk1[0];
    sk2BySk1_2.p <== sk2BySk1[1];

    pk1_1.out === 1;
    pk1_2.out === 1;
    pk2_1.out === 1;
    pk2_1.out === 1;

    sk1BySk2_1.out === 1;
    sk1BySk2_2.out === 1;
    sk2BySk1_1.out === 1;
    sk2BySk1_2.out === 1;

    // verify keys
    component k1Valid = VerifyKey();
    k1Valid.pk <== pk1;
    k1Valid.sk <== sk1;

    component k2Valid = VerifyKey();
    k2Valid.pk <== pk2;
    k2Valid.sk <== sk2;

    component sk1PointDecrypted = Decrypt();
    component sk2PointDecrypted = Decrypt();

    sk1PointDecrypted.ke <== sk1BySk2[0];
    sk1PointDecrypted.eM <== sk1BySk2[1];
    sk1PointDecrypted.d <== sk2;

    sk2PointDecrypted.ke <== sk2BySk1[0];
    sk2PointDecrypted.eM <== sk2BySk1[1];
    sk2PointDecrypted.d <== sk1;

    // elgamal encryption encrypts curve points. In order to relate between curve points and secret keys,
    // secret keys must be generated by hashing curve points.

    component sk1Decrypted = Poseidon(2);
    component sk2Decrypted = Poseidon(2);

    sk1Decrypted.inputs <== sk1PointDecrypted.dM;
    sk2Decrypted.inputs <== sk2PointDecrypted.dM;

    sk1Decrypted.out === sk1;
    sk2Decrypted.out === sk2;
}
